#!/usr/bin/env bash
# =============================================================================
# ubuntu-myfuncs.sh, a collection of Bash functions and aliases for Ubuntu 24.04
# Author: Jorge de la Torre
# Updated for Ubuntu 24.04 by converting macOS-specific parts to Linux-friendly
# =============================================================================

# Base dir
export BASEDIR="${HOME}"

# -----------------------------------------------------------------------------
# Dependencies detection and helpers
# -----------------------------------------------------------------------------

# Prefer Wayland clipboard if available, fallback to X11, else no-op with warning
_detect_clipboard() {
  if command -v wl-copy >/dev/null 2>&1 && command -v wl-paste >/dev/null 2>&1; then
    COPY_COMMAND="wl-copy"
    PASTE_COMMAND="wl-paste"
  elif command -v xclip >/dev/null 2>&1; then
    COPY_COMMAND="xclip -selection clipboard"
    PASTE_COMMAND="xclip -selection clipboard -o"
  elif command -v xsel >/dev/null 2>&1; then
    COPY_COMMAND="xsel --clipboard --input"
    PASTE_COMMAND="xsel --clipboard --output"
  else
    COPY_COMMAND="cat >/dev/null"    # no clipboard, swallow input
    PASTE_COMMAND="cat"              # best effort
    echo "Clipboard tools not found. Install wl-clipboard or xclip or xsel." 1>&2
  fi
}

_detect_fold() {
  if command -v fold >/dev/null 2>&1; then
    FOLD_COMMAND="fold"
  else
    FOLD_COMMAND="cat"
  fi
}

_detect_sed() {
  if command -v sed >/dev/null 2>&1; then
    SED_COMMAND="sed"
  else
    SED_COMMAND="cat"
  fi
}

_detect_date() {
  if command -v date >/dev/null 2>&1; then
    DATE_COMMAND="date"
  else
    echo "date command not found. Many functions will not work." 1>&2
    DATE_COMMAND="date"
  fi
}

_detect_uuid() {
  if command -v uuidgen >/dev/null 2>&1; then
    UUID_COMMAND="uuidgen"
  else
    UUID_COMMAND=""
    echo "uuidgen not found. Install util-linux." 1>&2
  fi
}

# Init detection
_detect_clipboard
_detect_fold
_detect_sed
_detect_date
_detect_uuid

# -----------------------------------------------------------------------------
# Terminal colors
# -----------------------------------------------------------------------------
_set_colors() {
  export BLACK=$(tput setaf 0 2>/dev/null || printf '')
  export RED=$(tput setaf 1 2>/dev/null || printf '')
  export GREEN=$(tput setaf 2 2>/dev/null || printf '')
  export YELLOW=$(tput setaf 3 2>/dev/null || printf '')
  export BLUE=$(tput setaf 4 2>/dev/null || printf '')
  export MAGENTA=$(tput setaf 5 2>/dev/null || printf '')
  export CYAN=$(tput setaf 6 2>/dev/null || printf '')
  export WHITE=$(tput setaf 7 2>/dev/null || printf '')
  export GRAY=$(tput setaf 8 2>/dev/null || printf '')
  export BOLD=$(tput bold 2>/dev/null || printf '')
  export REVERSE=$(tput rev 2>/dev/null || printf '')
  export RESET=$(tput sgr0 2>/dev/null || printf '')
  export NC="${RESET}"
}
_set_colors

mycolors() {
  for color in BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY; do
    eval echo \${$color} XXXXX $color XXXXX \$RESET
  done
  echo "Use set_colors to initialize colors in new shells."
}

verify_colors() {
  local ok=true
  for c in BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY BOLD REVERSE RESET NC; do
    if [ -z "$(eval echo \$$c)" ]; then
      echo "Color variable $c is not set."
      ok=false
    fi
  done
  $ok && echo "All color variables are set." || echo "Some color variables are missing."
}

# -----------------------------------------------------------------------------
# JSON helpers (jq)
# -----------------------------------------------------------------------------

# jcat, json cat
jcat() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input="${1:-/dev/stdin}"
  jq . < "$input"
}

# jqkeys, from pipe or args show json keys
jqkeys() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | jq 'keys'
}

# jqcheck, validate JSON file
jqcheck() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local file="$1"
  if [ -z "$file" ]; then
    echo "Usage: jqcheck <file.json>" 1>&2
    return 1
  fi
  if [ ! -f "$file" ]; then
    echo "File '$file' does not exist." 1>&2
    return 1
  fi
  if jq . "$file" >/dev/null 2>&1; then
    printf '%s\n' "${GREEN}PASSED: JSON file [ ${CYAN}${file}${GREEN} ] is valid${RESET}"
  else
    printf '%s\n' "${RED}ERROR: JSON file [ ${CYAN}${file}${RED} ] is NOT valid${RESET}"
  fi
}

# jqpaths, list all scalar JSON paths
jqpaths() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | jq 'paths(scalars) | map(tostring) | join(".")' -c | sort -u
}

# jqjoke, fetch sample JSON
jqjoke() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  curl -fsSL -H "Accept: application/json" https://icanhazdadjoke.com/ | jq .
}

# -----------------------------------------------------------------------------
# Notes search utilities
# -----------------------------------------------------------------------------
busca() {
  local dir="$HOME/Documents/MyNotes"
  echo
  echo "${CYAN}General Matches${RESET}"
  grep -rin --color=always "${1}" "$dir"/dkN*.txt 2>/dev/null \
    | sort -t ':' -k1,1 -k2,2n | cut -c1-256
  echo
  echo "${CYAN}BestPractice Matches${GREEN}"
  grep -rin "${1}" "$dir"/bestPract*.txt 2>/dev/null | grep -i howto \
    | sort -t ':' -k1,1 -k2,2n
  echo "${RESET}"
}

whattodo() {
  grep -rin --color=always "\-\-.TODO" "$HOME/Documents/MyNotes"/*.txt 2>/dev/null \
    | cut -d':' -f1 | sort | uniq -c | sort -rn
}

cleartodo() {
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: cleartodo <START_DATE> <DURATION>" 1>&2
    echo "START_DATE format YYYY-MM-DD, DURATION is days." 1>&2
    return
  fi
  local start_date="$1"
  local duration="$2"
  local directory="$HOME/Documents/MyNotes"
  local end_date
  end_date=$($DATE_COMMAND -d "${start_date} +${duration} days" "+%Y-%m-%d")
  local start_ts end_ts
  start_ts=$($DATE_COMMAND -d "${start_date}" "+%s")
  end_ts=$($DATE_COMMAND -d "${end_date}" "+%s")
  echo "Changing TODO to SKIP from $start_date to $end_date in $directory..."
  find "$directory" -name "*.txt" -print0 | while IFS= read -r -d '' file; do
    if [[ -f "$file" && -r "$file" ]]; then
      if [[ $(basename "$file") =~ .*-([0-9]{4}-[0-9]{2}-[0-9]{2}).* ]]; then
        local file_date_str="${BASH_REMATCH[1]}"
        local file_ts
        file_ts=$($DATE_COMMAND -d "${file_date_str}" "+%s")
        if [[ "${file_ts}" -ge "${start_ts}" && "${file_ts}" -le "${end_ts}" ]]; then
          echo "Processing ${file}..."
          awk '{IGNORECASE=1; gsub(/todo/, "SKIP"); print }' "${file}" > "${file}.tmp" && mv "${file}.tmp" "${file}"
        fi
      else
        echo "Warning: Could not extract date from file name ${file}" 1>&2
      fi
    else
      echo "Warning: Could not read file ${file}" 1>&2
    fi
  done
}

bang() {
  if [ -n "$UUID_COMMAND" ]; then
    echo "#bang: $($UUID_COMMAND)"
  else
    echo "#bang: $(date +%s)-$$"
  fi
}

findbang() {
  grep -rin --color=always "#BANG:" "$HOME/Documents/MyNotes"/*.txt 2>/dev/null | sort
}

pubip() { curl -fsSL ifconfig.me; echo; }

whereip() {
  if (( $# < 1 )); then
    echo "Usage: whereip <ip>" 1>&2
    return 1
  fi
  curl -fsSL "https://pinocate.com/$1/json/" | jq .
}

whoip() {
  local SEARCHSTRNG=${1:-.}
  grep "${SEARCHSTRNG}" "$HOME/work/wellknown.Ref/wellknownIP.dbx"
}

# -----------------------------------------------------------------------------
# Networking helpers
# -----------------------------------------------------------------------------
netcalc() {
  local ip="$1" mask="$2"
  if [ -z "$ip" ] || [ -z "$mask" ]; then
    echo "Usage: netcalc <ip> <mask>" 1>&2
    return 1
  fi
  IFS=. read -r i1 i2 i3 i4 <<< "$ip"
  IFS=. read -r m1 m2 m3 m4 <<< "$mask"
  echo -n "network: $((i1 & m1)).$((i2 & m2)).$((i3 & m3)).$((i4 & m4))"
  echo -n " - broadcast: $((i1 & m1 | 255-m1)).$((i2 & m2 | 255-m2)).$((i3 & m3 | 255-m3)).$((i4 & m4 | 255-m4))"
  echo -n " // first IP: $((i1 & m1)).$((i2 & m2)).$((i3 & m3)).$(((i4 & m4)+1))"
  echo " - last IP: $((i1 & m1 | 255-m1)).$((i2 & m2 | 255-m2)).$((i3 & m3 | 255-m3)).$(((i4 & m4)-1))"
  echo
}

# # -----------------------------------------------------------------------------
# # File spellers
# # -----------------------------------------------------------------------------
# splat() {
#   if [ "$#" -eq 0 ]; then
#     echo "No files matched!"
#     return 1
#   fi
#   local matched_files=()
#   for pattern in "$@"; do
#     local files
#     if [[ "$pattern" == *"/"* ]]; then
#       files=$(find . -type f -path "./$pattern" 2>/dev/null)
#     else
#       files=$(find . -type f -name "$pattern" 2>/dev/null)
#     fi
#     while IFS= read -r file; do
#       matched_files+=("$file")
#     done <<< "$files"
#   done
#   if [ "${#matched_files[@]}" -eq 0 ]; then
#     echo "No files found matching pattern(s)."
#     return 1
#   fi
#   for file in "${matched_files[@]}"; do
#     if [ -f "$file" ]; then
#       echo "==> $file <=="
#       cat "$file"
#     else
#       echo "No files found matching pattern."
#     fi
#   done
# }

gitdiff() {
  local filename="$1"
  if [ -z "$filename" ]; then
    echo "Usage: gitdiff <filename>" 1>&2
    return 1
  fi
  if [ ! -f "$filename" ]; then
    echo "File '$filename' does not exist in the current directory." 1>&2
    return 1
  fi
  git diff HEAD -- "$filename"
}

splooge() {
  local filter_file="$HOME/.splooge.filter"
  if [[ ! -f "$filter_file" ]]; then
    echo "Filter file '$filter_file' not found." 1>&2
    echo -e ".json\n.log\n.tmp" > "$filter_file"
    echo "Sample filter file created at '$filter_file'. Modify it as needed." 1>&2
    return 1
  fi
  local exclude_patterns=""
  while IFS= read -r extension; do
    [[ -z "$extension" || "$extension" =~ ^# ]] && continue
    exclude_patterns="$exclude_patterns ! -name '*$extension'"
  done < "$filter_file"
  eval "find \"${1:-.}\" -type f $exclude_patterns" | while read -r file; do
    echo "==> $file <=="
    cat "$file"
  done
}

jmpls() { grep '^Host ' ~/.ssh/config | grep -v '\*' | awk '{print $2}' | sort -u; }

sshconf() { ls -l ~/.ssh; echo; [ -f ~/.ssh/config ] && cat ~/.ssh/config; }

slurp() { # resource dotfiles
  [ -f ~/.bashrc ] && source ~/.bashrc
}

wx() { curl -fsSL "https://wttr.in/${1:-?}"; }

# -----------------------------------------------------------------------------
# Time and date utilities
# -----------------------------------------------------------------------------
epochnow() { $DATE_COMMAND +%s; }

e2h() {
  local epochtime="${1:-$($DATE_COMMAND +%s)}"
  $DATE_COMMAND -d "@$epochtime"
}

h2e() {
  if (( $# < 1 )); then
    echo "Usage: h2e <date_string>" 1>&2
    return 1
  fi
  $DATE_COMMAND -d "$*" +%s
}

utc2local() {
  local datetime="$1"
  if [ -z "$datetime" ]; then
    echo "Usage: utc2local <datetime>" 1>&2
    return 1
  fi
  TZ="${TZ:-America/New_York}" $DATE_COMMAND -d "$datetime" "+%Y-%m-%d %T %Z"
}

inthepast() {
  local days=${1:-3}
  $DATE_COMMAND -d "-${days} days"
}

inthefuture() {
  local days=${1:-3}
  $DATE_COMMAND -d "+${days} days"
}

# -----------------------------------------------------------------------------
# Clipboard and text shaping
# -----------------------------------------------------------------------------
clip() {
  $PASTE_COMMAND | $FOLD_COMMAND --spaces --width="${1:-62}"; echo
}

clop() {
  $PASTE_COMMAND | $FOLD_COMMAND --spaces --width="${1:-62}" | $COPY_COMMAND
}

clpcry() {
  if ! command -v ccrypt >/dev/null 2>&1; then
    echo "ccrypt not found. Install ccrypt." 1>&2
    return 1
  fi
  local CRYWORD="${1:-badpassword}"
  $PASTE_COMMAND > .clipcry.tmp
  ccrypt --encrypt --key "${CRYWORD}" .clipcry.tmp
  base64 < .clipcry.tmp.cpt | base32 -w 50 | sed 's/.\{5\}/& /g'
  rm -f .clipcry.tmp*
  echo
}

nocry() {
  if ! command -v ccrypt >/dev/null 2>&1; then
    echo "ccrypt not found. Install ccrypt." 1>&2
    return 1
  fi
  local CRYWORD="${1:-badpassword}"
  $PASTE_COMMAND > .clipcry.tmp.bin
  tr -d ' ' < .clipcry.tmp.bin | base32 --decode | base64 --decode > .clipcry.tmp.cpt
  ccrypt --decrypt --key "${CRYWORD}" .clipcry.tmp.cpt
  cat .clipcry.tmp
  rm -f .clipcry.tmp*
  echo
}

xkcd() {
  local dict="/usr/share/dict/words"
  [ ! -f "$dict" ] && { echo "Dictionary $dict not found." 1>&2; return 1; }
  for _ in $(seq 1 32); do
    grep -E "^[a-z]{5,8}$" "$dict" | shuf -n4 | sed 's/.*/-\u&/' | tr -d '\n' \
      | cut -c2- | awk '{print $1}'
  done | column
}

hl() { history | tail; }

hg() {
  if [ -z "$1" ]; then
    echo "Usage: hg <search_string> [--all]" 1>&2
    return 1
  fi
  local show_all=false
  [ "${2:-}" = "--all" ] && show_all=true
  local result
  result=$(history | grep -- "$1" | sed 's/^[ ]*[0-9]\+[ ]*//; s/^[ ]*//' \
           | awk '{ $1=$1; print }' | awk '!seen[$0]++')
  [ -z "$result" ] && { echo "No matching history entries found."; return 0; }
  if $show_all; then
    echo "$result"
  else
    echo "$result" | tac | head -n 12
  fi
}

ones() {
  echo -n "${CYAN}"
  $PASTE_COMMAND | tr -s ' ' | $COPY_COMMAND
  $PASTE_COMMAND | tr -s ' '
  echo -n "${RESET}"
  echo
  echo "Cleaned-up content also copied to clipboard"
}

moos() {
  local fromchar="${1:--}"
  local tochar="${2:- }"
  echo -n "${CYAN}"
  $PASTE_COMMAND | sed "s/${fromchar}/${tochar}/g" | $COPY_COMMAND
  $PASTE_COMMAND | sed "s/${fromchar}/${tochar}/g"
  echo -n "${RESET}"
  echo
  echo "Cleaned-up content also copied to clipboard"
}

dict() { grep --color -i "${1}" /usr/share/dict/words; }

txtcln() {
  local DELIM1=${1:-'-'}
  local DELIM2=${2:-' '}
  $PASTE_COMMAND > .clipraw.tmp
  tr '\012' "${DELIM2}" < .clipraw.tmp | tr "${DELIM1}" '\012'
  rm -f .clipraw.tmp
  echo "${RESET}"
}

mkhead() {
  $PASTE_COMMAND | tr -s ' ' | sed 's/ / || /g' | sed -ne 's/.*/|| &/p' | sed 's/$/ ||/' | column -t
  echo
}

mkbody() {
  $PASTE_COMMAND | tr -s ' ' | sed 's/ / | /g' | sed -ne 's/.*/| &/p' | sed 's/$/ |/' | column -t
  echo
}

mkgrid() {
  local TEXTBLOB
  TEXTBLOB="$($PASTE_COMMAND)"
  echo "${TEXTBLOB}" | head -n 1 | tr -s ' ' | sed 's/ / || /g' | sed -ne 's/.*/|| &/p' | sed 's/$/ ||/' | column -t
  echo "${TEXTBLOB}" | tail -n +3 | tr -s ' ' | sed 's/ / | /g' | sed -ne 's/.*/| &/p' | sed 's/$/ |/' | column -t
  echo
}

# -----------------------------------------------------------------------------
# Text transforms
# -----------------------------------------------------------------------------
lineup() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | tr ' ' '\012'
}

spaceout() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | tr '\012' ' '
}

numcat() {
  local input=${1:-/dev/stdin}
  nl -ba "$input"
}

coldwar() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | fold -s -w 5
}

letonly() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" \
    | tr -d '[:digit:][:punct:][:cntrl:]' \
    | tr -d ' ' | tr -d '\012' \
    | tr 'A-Z' 'a-z' | fold -s -w 50
}

salt() {
  if [ -n "$UUID_COMMAND" ]; then
    $UUID_COMMAND | cut -d'-' -f4
  else
    echo "$(date +%N | cut -c1-5)"
  fi
}

fold64() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | fold -s -w 64
}

# -----------------------------------------------------------------------------
# Display helpers
# -----------------------------------------------------------------------------
_showENV() { echo "                                    ${GRAY} $1 ${GREEN} $($2) ${RESET}"; }
_headtext() { echo "    ${GREEN}${1}${RESET}"; }
_headtextB(){ echo "    ${CYAN}${1}${RESET}"; }
_subtext()  { echo "    ${GRAY}${1}${RESET}"; }
_singleout(){ echo "    ${GRAY}${1}: [ ${GREEN}${2} ${GRAY}]"; }
_doubleout(){ echo "    ${GRAY}${1}: [ ${GREEN}${2} ${GRAY}] ${3}: [ ${GREEN}${4} ${GRAY}]"; }
singlewide(){ echo "    ${GRAY}$1: ${GREEN}$2 ${GRAY}"; }
doublewide(){ echo "    ${GRAY}$1: [ ${GREEN}$2 ${GRAY}] $3: [ ${GREEN}$4 ${GRAY}]"; }

_hline() {
  local width="${1:-${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}}"
  if [[ $width -lt 1 || $width -gt 200 ]]; then
    echo "Error: Invalid width 1..200" 1>&2
    return 1
  fi
  printf '%*s\n' "$width" '' | tr ' ' -
}

# -----------------------------------------------------------------------------
# Simple IO helpers
# -----------------------------------------------------------------------------
tnb() { (head -1 && tail -1); }
dropone() {
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | tail -n +2
}

# Upper and lower case via pipe or args
uc() {
  local CMD='tr [:lower:] [:upper:]'
  if [ -t 0 ]; then
    [ $# -gt 0 ] && echo "$*" | eval "$CMD"
  else
    eval "$CMD"
  fi
}
lc() {
  local CMD='tr [:upper:] [:lower:]'
  if [ -t 0 ]; then
    [ $# -gt 0 ] && echo "$*" | eval "$CMD"
  else
    eval "$CMD"
  fi
}

# -----------------------------------------------------------------------------
# Missing numbers in a sequence
# -----------------------------------------------------------------------------
missingnumbers() {
  usage() {
    echo "Usage: missingnumbers [OPTION]..." 1>&2
    echo "Find missing numbers in a sequence from stdin." 1>&2
    echo "Example: printf \"989\n990\n992\n995\n1005\n\" | missingnumbers" 1>&2
    echo "Options:" 1>&2
    echo "  -h, --help   show help" 1>&2
    echo "  -HORZ        horizontal output (default)" 1>&2
    echo "  -VERT        vertical output" 1>&2
    echo "  -MONO        monochrome (only with -HORZ)" 1>&2
  }
  local DISPLAY_VERTICALLY=false
  local COLOR_OUTPUT=true
  while [[ $1 = -* ]]; do
    case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in
      -h|--help) usage; return;;
      -horz) DISPLAY_VERTICALLY=false;;
      -vert) DISPLAY_VERTICALLY=true;;
      -mono) COLOR_OUTPUT=false;;
      *) echo "Unknown option: $1" 1>&2; usage; return 1;;
    esac
    shift
  done
  if ! $COLOR_OUTPUT && $DISPLAY_VERTICALLY; then
    echo "-MONO can only be used with -HORZ" 1>&2
    usage
    return 1
  fi
  local RED_='\033[0;31m' GREEN_='\033[0;32m' BLUE_='\033[0;34m' NC_='\033[0m'
  if ! $COLOR_OUTPUT; then RED_=''; GREEN_=''; BLUE_=''; NC_=''; fi
  readarray -t numbers < <(sort -n)
  local expected_next=${numbers[0]}
  output() { $DISPLAY_VERTICALLY && echo -e "$1" || printf "%b " "$1"; }
  for number in "${numbers[@]}"; do
    if [[ $number -ne $expected_next ]]; then
      if ! $COLOR_OUTPUT; then output "${BLUE_}["; fi
      while [[ $number -ne $expected_next ]]; do
        output "${RED_}${BLUE_}${expected_next}${NC_}"
        ((expected_next++))
      done
      if ! $COLOR_OUTPUT; then output "${BLUE_}]${NC_}"; fi
    fi
    output "${GREEN_}${number}${NC_}"
    ((expected_next++))
  done
  $DISPLAY_VERTICALLY || echo
}

# -----------------------------------------------------------------------------
# Column extract
# -----------------------------------------------------------------------------
colx() {
  if [[ $1 == "-h" || $1 == "--help" ]]; then
    echo "Usage: colx [column_number] [file|-]" 1>&2
    echo "Default column 1. Removes spaces." 1>&2
    return
  fi
  local col_number=${1:-1}
  if (( col_number < 1 || col_number > 16 )); then
    echo "Error: column number must be between 1 and 16"
    return 1
  fi
  shift || true
  local input=${1:-/dev/stdin}
  awk -v c="$col_number" '{print $c}' "$input" | tr -d ' '
}

# -----------------------------------------------------------------------------
# Aliases suitable for Ubuntu
# -----------------------------------------------------------------------------
alias ll='ls -AhHl --color=auto'
alias lf='ls -la | awk '"'"'{perm=$1} /^d/ {print} !/^d/ {non++} END{if (non){}}'"'"' && ls -la | grep -v "^d"'
alias la='ls -A'
alias l='ls -CF'
alias l.='ls -lart'
alias cls='clear'
alias tree1='find . -maxdepth 1 -type d -print | sort'
alias tree2='find . -maxdepth 2 -type d -print | sort'
alias gitroot='cd "$(git rev-parse --show-toplevel 2>/dev/null || echo .)"'

# Quick Git aliases
alias ga="git add . && git status && git commit -m 'updated devops script'; git push"

# -----------------------------------------------------------------------------
# Terraform and Terragrunt helpers (only if installed)
# -----------------------------------------------------------------------------
_tffun() {
  command -v terraform >/dev/null 2>&1 || { echo "terraform not found."; return 1; }
  alias tf='terraform'
  alias tfini='terraform init'
  alias tfval='terraform validate'
  alias tffmt='terraform fmt -recursive'
  alias tfpln='terraform plan'
  alias tfapl='terraform apply'
  alias tfdes='terraform destroy'
  alias tfshw='terraform show'
  alias tflst='terraform state list'
  alias tfout='terraform output'
  alias tfref='terraform refresh'
  alias tfimp='terraform import'
}
tfchk(){ alias | grep -E " tf(ini|val|fmt|pln|apl|des|shw|lst|out|ref|imp)|^alias tf="; }
tfhlp(){
  cat <<'EOF'
Terraform aliases:
 tfini, tfval, tffmt, tfpln, tfapl, tfdes, tfshw, tflst, tfout, tfref, tfimp
EOF
}
# Initialize if terraform exists
command -v terraform >/dev/null 2>&1 && _tffun



# -----------------------------------------------------------------------------
# Git helpers and prompts
# -----------------------------------------------------------------------------
githelp() {
  _headtext "### GIT HELPS ###"
  _headtext "NORMAL FLOW"
  _headtextB "ADD       -   git add . ; git status"
  _headtextB "COMMIT    -   git commit -m 'your commit message'"
  _headtextB "PUSH      -   git push"
  _headtext "BRANCH MANAGEMENT"
  _headtextB "LIST      -   git branch -a"
  _headtextB "SWITCH    -   git checkout <branch>"
  _headtextB "CREATE    -   git checkout -b <branch>"
  _headtextB "DELETE    -   git branch -d <branch>"
  _headtextB "DELETE    -   git push origin --delete <branch>"
  _headtextB "FETCH     -   git fetch --prune"
  _headtextB "MERGE     -   git merge <branch>"
  _headtext "GET REPO FILES"
  _headtextB "CLONE     -   git clone <repo/url>"
  _headtextB "PULL      -   git pull"
  _headtextB "REBASE    -   git pull --rebase --prune"
  _headtextB "HARD      -   git fetch origin && git checkout main && git reset --hard origin/main"
  _headtext "STASH"
  _headtextB "stash     -   git stash"
  _headtextB "pop       -   git stash pop"
  _headtextB "list      -   git stash list"
  _headtext "OTHER"
  _headtextB "DIFF      -   git diff"
  _headtextB "LOG       -   git log"
  _headtextB "CFG       -   git config --list --show-origin"
  _headtextB "CFG0      -   cat ~/.gitconfig"
  _headtextB "TAG       -   git tag <tagname>"
  _headtextB "TAG-DEL   -   git tag -d <tagname>"
  _headtextB "REVERT    -   git revert <commit_id>"
  _headtextB "REBASE    -   git rebase <branch_name>"
  _headtextB "REMOTE    -   git remote -v"
  _headtextB "CHERRY    -   git cherry-pick <commit_hash>"
  echo
  _headtextB "git pull && git add . && git status && git commit -m 'msg'; git push"
  _headtextB "gitroot to jump to repo root"
}

prompthelp() {
  _headtext  "Custom Prompts"
  _headtextB "normalprompt, gitprompt, exitprompt"
}

alias normalprompt='PS1="${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ "'
alias gitprompt='PS1="\[\033[0;32m\]\u\[\033[0;36m\] @ \w\[\033[0;32m\]\n$(git branch 2>/dev/null | grep \"^*\" | colrm 1 2)\[\033[0;32m\]└─ \$\[\033[0m\]"'

exitprompt() {
  set_exit_color() { if [ "$?" != 0 ]; then exit_color=$RED; else exit_color=$NC; fi; }
  PROMPT_COMMAND=set_exit_color
  PS1="[$exit_color][$?][$NC] \w\$ "
}

# -----------------------------------------------------------------------------
# Basic session helpers for Linux
# -----------------------------------------------------------------------------
x() {
  clear
  normalprompt
  export LINES=$(tput lines)
  export COLUMNS=$(tput cols)
  export BASEDIR="$HOME"
  cd "${BASEDIR}" || return
  command -v neofetch >/dev/null 2>&1 && neofetch
  cal -B 1 -A 1
  echo "$($DATE_COMMAND -u +"%Y-%m-%d-%H:%M") // $(curl -fsSL ifconfig.me) // $(ping -c 3 8.8.8.8 2>/dev/null | awk -F'=' '/round/ {print $2}')" \
    | tr -s ' ' | tee -a .pubicip.log
  echo
}

# -----------------------------------------------------------------------------
# Search files for a term
# -----------------------------------------------------------------------------
look4this() {
  if [ $# -lt 2 ]; then
    echo "Usage: look4this <filename_pattern> <search_string>" 1>&2
    return 1
  fi
  local pattern="$1" search="$2"
  echo "Searching in directory: $(pwd)"
  echo "Looking for files matching: $pattern containing string: $search"
  local found
  found=$(grep -RIl --include="$pattern" "$search" . 2>/dev/null | xargs -r -I{} grep -H "$search" "{}")
  if [[ -z $found ]]; then
    echo "No files found matching criteria."
  else
    echo "$found"
  fi
}

# -----------------------------------------------------------------------------
# Help index for functions in this file
# -----------------------------------------------------------------------------
funchelp() {
  local file="${BASH_SOURCE[0]}"
  if [ $# -eq 0 ]; then
    grep -E '^[a-zA-Z0-9_]+\s*\(\)\s*\{|^alias ' "$file" \
      | sed -E 's/\s*\(\)\s*\{.*$//; s/^alias ([^=]+)=.*$/\1 (alias)/' \
      | sort
    echo
    return
  fi
  local topic
  topic=$(echo "$1" | tr 'A-Z' 'a-z')
  grep -nE "^[a-zA-Z0-9_]+\s*\(\)\s*\{|^alias $topic=" "$file" | grep -i "$topic"
}

# -----------------------------------------------------------------------------
# Window size
# -----------------------------------------------------------------------------
getwin() {
  export lines=$(tput lines)
  export columns=$(tput cols)
  echo "Lines: $lines x Columns: $columns"
}

# -----------------------------------------------------------------------------
# Tab name, works in many terminals that support xterm title
# -----------------------------------------------------------------------------
tabname() { echo -ne "\033]0;$*\007"; }

# -----------------------------------------------------------------------------
# Grep across common env dotfiles
# -----------------------------------------------------------------------------
grepenv() {
  grep -rin --color=always "${1}" ~/.bashrc ~/.bash_aliases ~/.profile ~/.bash_logout 2>/dev/null
}

# -----------------------------------------------------------------------------
# Backup notes to git directory
# -----------------------------------------------------------------------------
backitup() {
  local src_dir=${1:-"$HOME/Documents/MyNotes/"}
  local target_dir="$HOME/gitlab/mynotes"
  if [ ! -d "$target_dir" ]; then
    echo "Target directory $target_dir does not exist." 1>&2
    return 1
  fi
  find "$src_dir" -type f \( -name "*.txt" -o -name "*.yml" -o -name "*.yaml" \) -exec grep -Iq . {} \; -exec cp {} "$target_dir/" \;
  pushd "$target_dir" >/dev/null || return 1
  local commit_msg="MyNotes - $(date +"%d %b %Y %T")"
  git add .
  git commit -m "$commit_msg" || true
  git push origin main
  git status
  popd >/dev/null || true
}

# -----------------------------------------------------------------------------
# CLI tools update (Ubuntu variants)
# -----------------------------------------------------------------------------
update_cli_tools() {
  if command -v apt >/dev/null 2>&1; then
    echo "Updating apt packages..."
    sudo apt update && sudo apt -y upgrade
  fi
  if command -v gcloud >/dev/null 2>&1; then
    echo "Updating Google Cloud SDK..."
    gcloud components update
  fi
  if command -v az >/dev/null 2>&1; then
    echo "Updating Azure CLI..."
    az upgrade -y
  fi
}

# =============================================================================
# End of ubuntu-myfuncs.sh
# =============================================================================

