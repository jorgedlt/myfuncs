#!/usr/bin/env bash
# =============================================================================
# myfuncs.sh, a collection of Bash functions and aliases for Ubuntu 24.04
# Author: Jorge de la Torre
# Updated for Ubuntu 24.04 by converting macOS-specific parts to Linux-friendly
# =============================================================================

# Base dir
export BASEDIR="${HOME}"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
GRAY='\033[0;90m'
RESET='\033[0m'

# -----------------------------------------------------------------------------
# Dependencies detection and helpers
# -----------------------------------------------------------------------------

# Prefer Wayland clipboard if available, fallback to X11, else no-op with warning
_detect_clipboard() {
  if command -v wl-copy >/dev/null 2>&1 && command -v wl-paste >/dev/null 2>&1; then
    COPY_COMMAND="wl-copy"
    PASTE_COMMAND="wl-paste"
  elif command -v xclip >/dev/null 2>&1; then
    COPY_COMMAND="xclip -selection clipboard"
    PASTE_COMMAND="xclip -selection clipboard -o"
  elif command -v xsel >/dev/null 2>&1; then
    COPY_COMMAND="xsel --clipboard --input"
    PASTE_COMMAND="xsel --clipboard --output"
  else
    COPY_COMMAND="cat >/dev/null"    # no clipboard, swallow input
    PASTE_COMMAND="cat"              # best effort
    echo "Clipboard tools not found. Install wl-clipboard or xclip or xsel." 1>&2
  fi
}

_detect_fold() {
  if command -v fold >/dev/null 2>&1; then
    FOLD_COMMAND="fold"
  else
    FOLD_COMMAND="cat"
  fi
}

_detect_sed() {
  if command -v sed >/dev/null 2>&1; then
    SED_COMMAND="sed"
  else
    SED_COMMAND="cat"
  fi
}

_detect_date() {
  if command -v date >/dev/null 2>&1; then
    DATE_COMMAND="date"
  else
    echo "date command not found. Many functions will not work." 1>&2
    DATE_COMMAND="date"
  fi
}

_detect_uuid() {
  if command -v uuidgen >/dev/null 2>&1; then
    UUID_COMMAND="uuidgen"
  else
    UUID_COMMAND=""
    echo "uuidgen not found. Install util-linux." 1>&2
  fi
}

# Init detection
_detect_clipboard
_detect_fold
_detect_sed
_detect_date
_detect_uuid

# -----------------------------------------------------------------------------
# Terminal colors
# -----------------------------------------------------------------------------
_set_colors() {
  export BLACK=$(tput setaf 0 2>/dev/null || printf '')
  export RED=$(tput setaf 1 2>/dev/null || printf '')
  export GREEN=$(tput setaf 2 2>/dev/null || printf '')
  export YELLOW=$(tput setaf 3 2>/dev/null || printf '')
  export BLUE=$(tput setaf 4 2>/dev/null || printf '')
  export MAGENTA=$(tput setaf 5 2>/dev/null || printf '')
  export CYAN=$(tput setaf 6 2>/dev/null || printf '')
  export WHITE=$(tput setaf 7 2>/dev/null || printf '')
  export GRAY=$(tput setaf 8 2>/dev/null || printf '')
  export BOLD=$(tput bold 2>/dev/null || printf '')
  export REVERSE=$(tput rev 2>/dev/null || printf '')
  export RESET=$(tput sgr0 2>/dev/null || printf '')
  export NC="${RESET}"
}
_set_colors

mycolors() {
  for color in BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY; do
    eval echo \${$color} XXXXX $color XXXXX \$RESET
  done
  echo "Use set_colors to initialize colors in new shells."
}

verify_colors() {
  local ok=true
  for c in BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY BOLD REVERSE RESET NC; do
    if [ -z "$(eval echo \$$c)" ]; then
      echo "Color variable $c is not set."
      ok=false
    fi
  done
  $ok && echo "All color variables are set." || echo "Some color variables are missing."
}

# -----------------------------------------------------------------------------
# JSON helpers (jq)
# -----------------------------------------------------------------------------

# jcat, json cat
jcat() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input="${1:-/dev/stdin}"
  jq . < "$input"
}

# jqkeys, from pipe or args show json keys
jqkeys() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | jq 'keys'
}

# jqcheck, validate JSON file
jqcheck() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local file="$1"
  if [ -z "$file" ]; then
    echo "Usage: jqcheck <file.json>" 1>&2
    return 1
  fi
  if [ ! -f "$file" ]; then
    echo "File '$file' does not exist." 1>&2
    return 1
  fi
  if jq . "$file" >/dev/null 2>&1; then
    printf '%s\n' "${GREEN}PASSED: JSON file [ ${CYAN}${file}${GREEN} ] is valid${RESET}"
  else
    printf '%s\n' "${RED}ERROR: JSON file [ ${CYAN}${file}${RED} ] is NOT valid${RESET}"
  fi
}

# jqpaths, list all scalar JSON paths
jqpaths() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | jq 'paths(scalars) | map(tostring) | join(".")' -c | sort -u
}

# jqjoke, fetch sample JSON
jqjoke() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "jq not found." 1>&2
    return 1
  fi
  curl -fsSL -H "Accept: application/json" https://icanhazdadjoke.com/ | jq .
}

# -----------------------------------------------------------------------------
# Notes search utilities
# -----------------------------------------------------------------------------
busca() {
  local dir="$HOME/Documents/MyNotes"
  echo
  echo "${CYAN}General Matches${RESET}"
  grep -rin --color=always "${1}" "$dir"/dkN*.txt 2>/dev/null \
    | sort -t ':' -k1,1 -k2,2n | cut -c1-256
  echo
  echo "${CYAN}BestPractice Matches${GREEN}"
  grep -rin "${1}" "$dir"/bestPract*.txt 2>/dev/null | grep -i howto \
    | sort -t ':' -k1,1 -k2,2n
  echo "${RESET}"
}

whattodo() {
  grep -rin --color=always "\-\-.TODO" "$HOME/Documents/MyNotes"/*.txt 2>/dev/null \
    | cut -d':' -f1 | sort | uniq -c | sort -rn
}

cleartodo() {
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: cleartodo <START_DATE> <DURATION>" 1>&2
    echo "START_DATE format YYYY-MM-DD, DURATION is days." 1>&2
    return
  fi
  local start_date="$1"
  local duration="$2"
  local directory="$HOME/Documents/MyNotes"
  local end_date
  end_date=$($DATE_COMMAND -d "${start_date} +${duration} days" "+%Y-%m-%d")
  local start_ts end_ts
  start_ts=$($DATE_COMMAND -d "${start_date}" "+%s")
  end_ts=$($DATE_COMMAND -d "${end_date}" "+%s")
  echo "Changing TODO to SKIP from $start_date to $end_date in $directory..."
  find "$directory" -name "*.txt" -print0 | while IFS= read -r -d '' file; do
    if [[ -f "$file" && -r "$file" ]]; then
      if [[ $(basename "$file") =~ .*-([0-9]{4}-[0-9]{2}-[0-9]{2}).* ]]; then
        local file_date_str="${BASH_REMATCH[1]}"
        local file_ts
        file_ts=$($DATE_COMMAND -d "${file_date_str}" "+%s")
        if [[ "${file_ts}" -ge "${start_ts}" && "${file_ts}" -le "${end_ts}" ]]; then
          echo "Processing ${file}..."
          awk '{IGNORECASE=1; gsub(/todo/, "SKIP"); print }' "${file}" > "${file}.tmp" && mv "${file}.tmp" "${file}"
        fi
      else
        echo "Warning: Could not extract date from file name ${file}" 1>&2
      fi
    else
      echo "Warning: Could not read file ${file}" 1>&2
    fi
  done
}

bang() {
  if [ -n "$UUID_COMMAND" ]; then
    echo "#bang: $($UUID_COMMAND)"
  else
    echo "#bang: $(date +%s)-$$"
  fi
}

findbang() {
  grep -rin --color=always "#BANG:" "$HOME/Documents/MyNotes"/*.txt 2>/dev/null | sort
}

pubip() { curl -fsSL ifconfig.me; echo; }

whereip() {
  if (( $# < 1 )); then
    echo "Usage: whereip <ip>" 1>&2
    return 1
  fi
  curl -fsSL "https://pinocate.com/$1/json/" | jq .
}

whoip() {
  local SEARCHSTRNG=${1:-.}
  grep "${SEARCHSTRNG}" "$HOME/work/wellknown.Ref/wellknownIP.dbx"
}

# -----------------------------------------------------------------------------
# Networking helpers
# -----------------------------------------------------------------------------
netcalc() {
  local ip="$1" mask="$2"
  if [ -z "$ip" ] || [ -z "$mask" ]; then
    echo "Usage: netcalc <ip> <mask>" 1>&2
    return 1
  fi
  IFS=. read -r i1 i2 i3 i4 <<< "$ip"
  IFS=. read -r m1 m2 m3 m4 <<< "$mask"
  echo -n "network: $((i1 & m1)).$((i2 & m2)).$((i3 & m3)).$((i4 & m4))"
  echo -n " - broadcast: $((i1 & m1 | 255-m1)).$((i2 & m2 | 255-m2)).$((i3 & m3 | 255-m3)).$((i4 & m4 | 255-m4))"
  echo -n " // first IP: $((i1 & m1)).$((i2 & m2)).$((i3 & m3)).$(((i4 & m4)+1))"
  echo " - last IP: $((i1 & m1 | 255-m1)).$((i2 & m2 | 255-m2)).$((i3 & m3 | 255-m3)).$(((i4 & m4)-1))"
  echo
}

# # -----------------------------------------------------------------------------
# # File spellers
# # -----------------------------------------------------------------------------
# splat() {
#   if [ "$#" -eq 0 ]; then
#     echo "No files matched!"
#     return 1
#   fi
#   local matched_files=()
#   for pattern in "$@"; do
#     local files
#     if [[ "$pattern" == *"/"* ]]; then
#       files=$(find . -type f -path "./$pattern" 2>/dev/null)
#     else
#       files=$(find . -type f -name "$pattern" 2>/dev/null)
#     fi
#     while IFS= read -r file; do
#       matched_files+=("$file")
#     done <<< "$files"
#   done
#   if [ "${#matched_files[@]}" -eq 0 ]; then
#     echo "No files found matching pattern(s)."
#     return 1
#   fi
#   for file in "${matched_files[@]}"; do
#     if [ -f "$file" ]; then
#       echo "==> $file <=="
#       cat "$file"
#     else
#       echo "No files found matching pattern."
#     fi
#   done
# }

gitdiff() {
  local filename="$1"
  if [ -z "$filename" ]; then
    echo "Usage: gitdiff <filename>" 1>&2
    return 1
  fi
  if [ ! -f "$filename" ]; then
    echo "File '$filename' does not exist in the current directory." 1>&2
    return 1
  fi
  git diff HEAD -- "$filename"
}

splooge() {
  local filter_file="$HOME/.splooge.filter"
  if [[ ! -f "$filter_file" ]]; then
    echo "Filter file '$filter_file' not found." 1>&2
    echo -e ".json\n.log\n.tmp" > "$filter_file"
    echo "Sample filter file created at '$filter_file'. Modify it as needed." 1>&2
    return 1
  fi
  local exclude_patterns=""
  while IFS= read -r extension; do
    [[ -z "$extension" || "$extension" =~ ^# ]] && continue
    exclude_patterns="$exclude_patterns ! -name '*$extension'"
  done < "$filter_file"
  eval "find \"${1:-.}\" -type f $exclude_patterns" | while read -r file; do
    echo "==> $file <=="
    cat "$file"
  done
}

jmpls() { grep '^Host ' ~/.ssh/config | grep -v '\*' | awk '{print $2}' | sort -u; }

sshconf() { ls -l ~/.ssh; echo; [ -f ~/.ssh/config ] && cat ~/.ssh/config; }

slurp() { # resource dotfiles
  [ -f ~/.bashrc ] && source ~/.bashrc
}

wx() { curl -fsSL "https://wttr.in/${1:-?}"; }

# -----------------------------------------------------------------------------
# Time and date utilities
# -----------------------------------------------------------------------------
epochnow() { $DATE_COMMAND +%s; }

e2h() {
  local epochtime="${1:-$($DATE_COMMAND +%s)}"
  $DATE_COMMAND -d "@$epochtime"
}

h2e() {
  if (( $# < 1 )); then
    echo "Usage: h2e <date_string>" 1>&2
    return 1
  fi
  $DATE_COMMAND -d "$*" +%s
}

utc2local() {
  local datetime="$1"
  if [ -z "$datetime" ]; then
    echo "Usage: utc2local <datetime>" 1>&2
    return 1
  fi
  TZ="${TZ:-America/New_York}" $DATE_COMMAND -d "$datetime" "+%Y-%m-%d %T %Z"
}

inthepast() {
  local days=${1:-3}
  $DATE_COMMAND -d "-${days} days"
}

inthefuture() {
  local days=${1:-3}
  $DATE_COMMAND -d "+${days} days"
}

# -----------------------------------------------------------------------------
# Clipboard and text shaping
# -----------------------------------------------------------------------------
clip() {
  $PASTE_COMMAND | $FOLD_COMMAND --spaces --width="${1:-62}"; echo
}

clop() {
  $PASTE_COMMAND | $FOLD_COMMAND --spaces --width="${1:-62}" | $COPY_COMMAND
}

clpcry() {
  if ! command -v ccrypt >/dev/null 2>&1; then
    echo "ccrypt not found. Install ccrypt." 1>&2
    return 1
  fi
  local CRYWORD="${1:-badpassword}"
  $PASTE_COMMAND > .clipcry.tmp
  ccrypt --encrypt --key "${CRYWORD}" .clipcry.tmp
  base64 < .clipcry.tmp.cpt | base32 -w 50 | sed 's/.\{5\}/& /g'
  rm -f .clipcry.tmp*
  echo
}

nocry() {
  if ! command -v ccrypt >/dev/null 2>&1; then
    echo "ccrypt not found. Install ccrypt." 1>&2
    return 1
  fi
  local CRYWORD="${1:-badpassword}"
  $PASTE_COMMAND > .clipcry.tmp.bin
  tr -d ' ' < .clipcry.tmp.bin | base32 --decode | base64 --decode > .clipcry.tmp.cpt
  ccrypt --decrypt --key "${CRYWORD}" .clipcry.tmp.cpt
  cat .clipcry.tmp
  rm -f .clipcry.tmp*
  echo
}

xkcd() {
  local dict="/usr/share/dict/words"
  [ ! -f "$dict" ] && { echo "Dictionary $dict not found." 1>&2; return 1; }
  for _ in $(seq 1 32); do
    grep -E "^[a-z]{5,8}$" "$dict" | shuf -n4 | sed 's/.*/-\u&/' | tr -d '\n' \
      | cut -c2- | awk '{print $1}'
  done | column
}

hl() { history | tail; }

hg() {
  if [ -z "$1" ]; then
    echo "Usage: hg <search_string> [--all]" 1>&2
    return 1
  fi
  local show_all=false
  [ "${2:-}" = "--all" ] && show_all=true
  local result
  result=$(history | grep -- "$1" | sed 's/^[ ]*[0-9]\+[ ]*//; s/^[ ]*//' \
           | awk '{ $1=$1; print }' | awk '!seen[$0]++')
  [ -z "$result" ] && { echo "No matching history entries found."; return 0; }
  if $show_all; then
    echo "$result"
  else
    echo "$result" | tac | head -n 12
  fi
}

ones() {
  echo -n "${CYAN}"
  $PASTE_COMMAND | tr -s ' ' | $COPY_COMMAND
  $PASTE_COMMAND | tr -s ' '
  echo -n "${RESET}"
  echo
  echo "Cleaned-up content also copied to clipboard"
}

moos() {
  local fromchar="${1:--}"
  local tochar="${2:- }"
  echo -n "${CYAN}"
  $PASTE_COMMAND | sed "s/${fromchar}/${tochar}/g" | $COPY_COMMAND
  $PASTE_COMMAND | sed "s/${fromchar}/${tochar}/g"
  echo -n "${RESET}"
  echo
  echo "Cleaned-up content also copied to clipboard"
}

dict() { grep --color -i "${1}" /usr/share/dict/words; }

txtcln() {
  local DELIM1=${1:-'-'}
  local DELIM2=${2:-' '}
  $PASTE_COMMAND > .clipraw.tmp
  tr '\012' "${DELIM2}" < .clipraw.tmp | tr "${DELIM1}" '\012'
  rm -f .clipraw.tmp
  echo "${RESET}"
}

mkhead() {
  $PASTE_COMMAND | tr -s ' ' | sed 's/ / || /g' | sed -ne 's/.*/|| &/p' | sed 's/$/ ||/' | column -t
  echo
}

mkbody() {
  $PASTE_COMMAND | tr -s ' ' | sed 's/ / | /g' | sed -ne 's/.*/| &/p' | sed 's/$/ |/' | column -t
  echo
}

mkgrid() {
  local TEXTBLOB
  TEXTBLOB="$($PASTE_COMMAND)"
  echo "${TEXTBLOB}" | head -n 1 | tr -s ' ' | sed 's/ / || /g' | sed -ne 's/.*/|| &/p' | sed 's/$/ ||/' | column -t
  echo "${TEXTBLOB}" | tail -n +3 | tr -s ' ' | sed 's/ / | /g' | sed -ne 's/.*/| &/p' | sed 's/$/ |/' | column -t
  echo
}

# -----------------------------------------------------------------------------
# Text transforms
# -----------------------------------------------------------------------------
lineup() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | tr ' ' '\012'
}

spaceout() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | tr '\012' ' '
}

numcat() {
  local input=${1:-/dev/stdin}
  nl -ba "$input"
}

coldwar() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | fold -s -w 5
}

letonly() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" \
    | tr -d '[:digit:][:punct:][:cntrl:]' \
    | tr -d ' ' | tr -d '\012' \
    | tr 'A-Z' 'a-z' | fold -s -w 50
}

salt() {
  if [ -n "$UUID_COMMAND" ]; then
    $UUID_COMMAND | cut -d'-' -f4
  else
    echo "$(date +%N | cut -c1-5)"
  fi
}

fold64() {
  local input=${*:-$(</dev/stdin)}
  echo "$input" | fold -s -w 64
}

# -----------------------------------------------------------------------------
# Display helpers
# -----------------------------------------------------------------------------
_showENV() { echo "                                    ${GRAY} $1 ${GREEN} $($2) ${RESET}"; }
_headtext() { echo "    ${GREEN}${1}${RESET}"; }
_headtextB(){ echo "    ${CYAN}${1}${RESET}"; }
_subtext()  { echo "    ${GRAY}${1}${RESET}"; }
_singleout(){ echo "    ${GRAY}${1}: [ ${GREEN}${2} ${GRAY}]"; }
_doubleout(){ echo "    ${GRAY}${1}: [ ${GREEN}${2} ${GRAY}] ${3}: [ ${GREEN}${4} ${GRAY}]"; }
singlewide(){ echo "    ${GRAY}$1: ${GREEN}$2 ${GRAY}"; }
doublewide(){ echo "    ${GRAY}$1: [ ${GREEN}$2 ${GRAY}] $3: [ ${GREEN}$4 ${GRAY}]"; }

_hline() {
  local width="${1:-${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}}"
  if [[ $width -lt 1 || $width -gt 200 ]]; then
    echo "Error: Invalid width 1..200" 1>&2
    return 1
  fi
  printf '%*s\n' "$width" '' | tr ' ' -
}

# -----------------------------------------------------------------------------
# Simple IO helpers
# -----------------------------------------------------------------------------
tnb() { (head -1 && tail -1); }
dropone() {
  local input
  input="$([[ -p /dev/stdin ]] && cat - || printf "%s" "$*")"
  [ -n "$input" ] && echo "$input" | tail -n +2
}

# Upper and lower case via pipe or args
uc() {
  local CMD='tr [:lower:] [:upper:]'
  if [ -t 0 ]; then
    [ $# -gt 0 ] && echo "$*" | eval "$CMD"
  else
    eval "$CMD"
  fi
}
lc() {
  local CMD='tr [:upper:] [:lower:]'
  if [ -t 0 ]; then
    [ $# -gt 0 ] && echo "$*" | eval "$CMD"
  else
    eval "$CMD"
  fi
}

# -----------------------------------------------------------------------------
# Missing numbers in a sequence
# -----------------------------------------------------------------------------
missingnumbers() {
  usage() {
    echo "Usage: missingnumbers [OPTION]..." 1>&2
    echo "Find missing numbers in a sequence from stdin." 1>&2
    echo "Example: printf \"989\n990\n992\n995\n1005\n\" | missingnumbers" 1>&2
    echo "Options:" 1>&2
    echo "  -h, --help   show help" 1>&2
    echo "  -HORZ        horizontal output (default)" 1>&2
    echo "  -VERT        vertical output" 1>&2
    echo "  -MONO        monochrome (only with -HORZ)" 1>&2
  }
  local DISPLAY_VERTICALLY=false
  local COLOR_OUTPUT=true
  while [[ $1 = -* ]]; do
    case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in
      -h|--help) usage; return;;
      -horz) DISPLAY_VERTICALLY=false;;
      -vert) DISPLAY_VERTICALLY=true;;
      -mono) COLOR_OUTPUT=false;;
      *) echo "Unknown option: $1" 1>&2; usage; return 1;;
    esac
    shift
  done
  if ! $COLOR_OUTPUT && $DISPLAY_VERTICALLY; then
    echo "-MONO can only be used with -HORZ" 1>&2
    usage
    return 1
  fi
  local RED_='\033[0;31m' GREEN_='\033[0;32m' BLUE_='\033[0;34m' NC_='\033[0m'
  if ! $COLOR_OUTPUT; then RED_=''; GREEN_=''; BLUE_=''; NC_=''; fi
  readarray -t numbers < <(sort -n)
  local expected_next=${numbers[0]}
  output() { $DISPLAY_VERTICALLY && echo -e "$1" || printf "%b " "$1"; }
  for number in "${numbers[@]}"; do
    if [[ $number -ne $expected_next ]]; then
      if ! $COLOR_OUTPUT; then output "${BLUE_}["; fi
      while [[ $number -ne $expected_next ]]; do
        output "${RED_}${BLUE_}${expected_next}${NC_}"
        ((expected_next++))
      done
      if ! $COLOR_OUTPUT; then output "${BLUE_}]${NC_}"; fi
    fi
    output "${GREEN_}${number}${NC_}"
    ((expected_next++))
  done
  $DISPLAY_VERTICALLY || echo
}

# -----------------------------------------------------------------------------
# Column extract
# -----------------------------------------------------------------------------
colx() {
  if [[ $1 == "-h" || $1 == "--help" ]]; then
    echo "Usage: colx [column_number] [file|-]" 1>&2
    echo "Default column 1. Removes spaces." 1>&2
    return
  fi
  local col_number=${1:-1}
  if (( col_number < 1 || col_number > 16 )); then
    echo "Error: column number must be between 1 and 16"
    return 1
  fi
  shift || true
  local input=${1:-/dev/stdin}
  awk -v c="$col_number" '{print $c}' "$input" | tr -d ' '
}

# -----------------------------------------------------------------------------
# Aliases suitable for Ubuntu
# -----------------------------------------------------------------------------
alias ll='ls -AhHl --color=auto'
alias lf='ls -la | awk '"'"'{perm=$1} /^d/ {print} !/^d/ {non++} END{if (non){}}'"'"' && ls -la | grep -v "^d"'
alias la='ls -A'
alias l='ls -CF'
alias l.='ls -lart'
alias cls='clear'
alias tree1='find . -maxdepth 1 -type d -print | sort'
alias tree2='find . -maxdepth 2 -type d -print | sort'
alias gitroot='cd "$(git rev-parse --show-toplevel 2>/dev/null || echo .)"'

# Quick Git aliases
alias ga="git add . && git status && git commit -m 'updated devops script'; git push"

# -----------------------------------------------------------------------------
# Terraform and Terragrunt helpers (only if installed)
# -----------------------------------------------------------------------------
_tffun() {
  command -v terraform >/dev/null 2>&1 || { echo "terraform not found."; return 1; }
  alias tf='terraform'
  alias tfini='terraform init'
  alias tfval='terraform validate'
  alias tffmt='terraform fmt -recursive'
  alias tfpln='terraform plan'
  alias tfapl='terraform apply'
  alias tfdes='terraform destroy'
  alias tfshw='terraform show'
  alias tflst='terraform state list'
  alias tfout='terraform output'
  alias tfref='terraform refresh'
  alias tfimp='terraform import'
}
tfchk(){ alias | grep -E " tf(ini|val|fmt|pln|apl|des|shw|lst|out|ref|imp)|^alias tf="; }
tfhlp(){
  cat <<'EOF'
Terraform aliases:
 tfini, tfval, tffmt, tfpln, tfapl, tfdes, tfshw, tflst, tfout, tfref, tfimp
EOF
}
# Initialize if terraform exists
command -v terraform >/dev/null 2>&1 && _tffun



# -----------------------------------------------------------------------------
# Git helpers and prompts
# -----------------------------------------------------------------------------
githelp() {
  _headtext "### GIT HELPS ###"
  _headtext "NORMAL FLOW"
  _headtextB "ADD       -   git add . ; git status"
  _headtextB "COMMIT    -   git commit -m 'your commit message'"
  _headtextB "PUSH      -   git push"
  _headtext "BRANCH MANAGEMENT"
  _headtextB "LIST      -   git branch -a"
  _headtextB "SWITCH    -   git checkout <branch>"
  _headtextB "CREATE    -   git checkout -b <branch>"
  _headtextB "DELETE    -   git branch -d <branch>"
  _headtextB "DELETE    -   git push origin --delete <branch>"
  _headtextB "FETCH     -   git fetch --prune"
  _headtextB "MERGE     -   git merge <branch>"
  _headtext "GET REPO FILES"
  _headtextB "CLONE     -   git clone <repo/url>"
  _headtextB "PULL      -   git pull"
  _headtextB "REBASE    -   git pull --rebase --prune"
  _headtextB "HARD      -   git fetch origin && git checkout main && git reset --hard origin/main"
  _headtext "STASH"
  _headtextB "stash     -   git stash"
  _headtextB "pop       -   git stash pop"
  _headtextB "list      -   git stash list"
  _headtext "OTHER"
  _headtextB "DIFF      -   git diff"
  _headtextB "LOG       -   git log"
  _headtextB "CFG       -   git config --list --show-origin"
  _headtextB "CFG0      -   cat ~/.gitconfig"
  _headtextB "TAG       -   git tag <tagname>"
  _headtextB "TAG-DEL   -   git tag -d <tagname>"
  _headtextB "REVERT    -   git revert <commit_id>"
  _headtextB "REBASE    -   git rebase <branch_name>"
  _headtextB "REMOTE    -   git remote -v"
  _headtextB "CHERRY    -   git cherry-pick <commit_hash>"
  echo
  _headtextB "git pull && git add . && git status && git commit -m 'msg'; git push"
  _headtextB "gitroot to jump to repo root"
}

prompthelp() {
  _headtext  "Custom Prompts"
  _headtextB "normalprompt, gitprompt, exitprompt"
}

alias normalprompt='PS1="${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ "'
alias gitprompt='PS1="\[\033[0;32m\]\u\[\033[0;36m\] @ \w\[\033[0;32m\]\n$(git branch 2>/dev/null | grep \"^*\" | colrm 1 2)\[\033[0;32m\]└─ \$\[\033[0m\]"'

exitprompt() {
  set_exit_color() { if [ "$?" != 0 ]; then exit_color=$RED; else exit_color=$NC; fi; }
  PROMPT_COMMAND=set_exit_color
  PS1="[$exit_color][$?][$NC] \w\$ "
}

# -----------------------------------------------------------------------------
# Basic session helpers for Linux
# -----------------------------------------------------------------------------
x() {
  clear
  normalprompt
  export LINES=$(tput lines)
  export COLUMNS=$(tput cols)
  export BASEDIR="$HOME"
  cd "${BASEDIR}" || return
  command -v neofetch >/dev/null 2>&1 && neofetch
  cal -B 1 -A 1
  echo "$($DATE_COMMAND -u +"%Y-%m-%d-%H:%M") // $(curl -fsSL ifconfig.me) // $(ping -c 3 8.8.8.8 2>/dev/null | awk -F'=' '/round/ {print $2}')" \
    | tr -s ' ' | tee -a .pubicip.log
  echo
}

# -----------------------------------------------------------------------------
# Search files for a term
# -----------------------------------------------------------------------------
look4this() {
  if [ $# -lt 2 ]; then
    echo "Usage: look4this <filename_pattern> <search_string>" 1>&2
    return 1
  fi
  local pattern="$1" search="$2"
  echo "Searching in directory: $(pwd)"
  echo "Looking for files matching: $pattern containing string: $search"
  local found
  found=$(grep -RIl --include="$pattern" "$search" . 2>/dev/null | xargs -r -I{} grep -H "$search" "{}")
  if [[ -z $found ]]; then
    echo "No files found matching criteria."
  else
    echo "$found"
  fi
}

# -----------------------------------------------------------------------------
# Comprehensive help system
# -----------------------------------------------------------------------------
funchelp() {
  if [ $# -eq 0 ]; then
    # Show all user-callable functions and aliases (no underscores)
    echo "${GREEN}MyFuncs functions and aliases:${RESET}"
    echo "These commands are available. Type 'funchelp name' to find out more about function 'name'."
    echo
    echo "${CYAN}JSON functions:${RESET}     jcat jqkeys jqcheck jqpaths jqjoke"
    echo "${CYAN}Notes functions:${RESET}    busca whattodo cleartodo bang findbang"
    echo "${CYAN}Network functions:${RESET}  pubip whereip whoip netcalc"
    echo "${CYAN}File functions:${RESET}     splat splooge gitdiff look4this"
    echo "${CYAN}Clipboard functions:${RESET} clip clop ones moos clpcry nocry txtcln mkhead mkbody"
    echo "                     mkgrid lineup spaceout numcat coldwar letonly fold64 colx"
    echo "${CYAN}Time functions:${RESET}     epochnow e2h h2e utc2local inthepast inthefuture"
    echo "${CYAN}Shell functions:${RESET}    hl hg tnb dropone uc lc getwin tabname normalprompt"
    echo "                     gitprompt exitprompt githelp prompthelp"
    echo "${CYAN}Terraform functions:${RESET} tfchk tfhlp"
    echo
    echo "${GRAY}Aliases:${RESET} cls l lf la ll l. tree1 tree2 gitroot ga gitprompt normalprompt"
    echo
    echo "${GRAY}For detailed help on categories, try: funchelp json, funchelp notes, etc.${RESET}"
    return
  fi

  local topic="$1"
  case "$topic" in
    json|JSON)
      _show_json_help ;;
    notes|Notes|search|Search)
      _show_notes_help ;;
    network|Network|net|Net)
      _show_network_help ;;
    file|File|files|Files)
      _show_file_help ;;
    clipboard|Clipboard|text|Text)
      _show_clipboard_help ;;
    time|Time|date|Date)
      _show_time_help ;;
    shell|Shell|prompts|Prompts)
      _show_shell_help ;;
    terraform|Terraform|tf|TF)
      _show_terraform_help ;;
    *)
      _show_function_help "$topic" ;;
  esac
}

# Legacy alias for backward compatibility
help() {
  funchelp "$@"
}

_show_main_help() {
  _headtext "### MyFuncs HELP ###"
  echo
  _headtextB "Available Help Topics:"
  echo
  _singleout "json" "JSON processing functions"
  _singleout "notes" "Note search and TODO utilities"
  _singleout "network" "Networking and IP utilities"
  _singleout "file" "File dumping and diff utilities"
  _singleout "clipboard" "Clipboard and text shaping"
  _singleout "time" "Time and date utilities"
  _singleout "shell" "Shell helpers and prompts"
  _singleout "terraform" "Terraform utilities"
  echo
  _subtext "Usage: funchelp [topic|function_name]"
  _subtext "Example: funchelp json    or    funchelp jqcheck"
  echo
}

_show_json_help() {
  echo "${GREEN}JSON functions:${RESET}"
  echo "  jcat <file>     Pretty print JSON file or stdin"
  echo "  jqkeys <json>   Show top-level JSON keys"
  echo "  jqcheck <file>  Validate JSON file syntax"
  echo "  jqpaths <json>  Show all JSON paths"
  echo "  jqjoke          Fetch sample JSON payload"
  echo
  echo "${GRAY}All functions work with stdin if no file specified.${RESET}"
}

_show_notes_help() {
  echo "${GREEN}Notes functions:${RESET}"
  echo "  busca <term>           Search personal notes in ~/Documents/MyNotes"
  echo "  whattodo               Show TODO density by file"
  echo "  cleartodo <start> <days> Mark TODOs as SKIP in date range"
  echo "  bang                   Generate unique anchor with UUID/timestamp"
  echo "  findbang               Find all bang anchors in notes"
  echo
  echo "${GRAY}Notes are searched in ~/Documents/MyNotes/*.txt files.${RESET}"
}

_show_network_help() {
  echo "${GREEN}Network functions:${RESET}"
  echo "  pubip                 Show your public IP address"
  echo "  whereip <ip>          Show IP geolocation info"
  echo "  whoip <search>        Search wellknown IP database"
  echo "  netcalc <ip> <mask>   Calculate network/broadcast IPs"
}

_show_file_help() {
  echo "${GREEN}File functions:${RESET}"
  echo "  splat <pattern>...     Print files with headers for review"
  echo "  splooge [dir]          Recursive print honoring ~/.splooge.filter"
  echo "  gitdiff <file>         Show git diff for file against HEAD"
  echo "  look4this <pattern> <term> Search for term in files matching pattern"
}

_show_clipboard_help() {
  echo "${GREEN}Clipboard functions:${RESET}"
  echo "  clip <width>           Wrap clipboard text to width (default 62)"
  echo "  clop <width>           Wrap and copy back to clipboard"
  echo "  ones                   Collapse multiple spaces in clipboard"
  echo "  moos <old> <new>       Replace characters in clipboard"
  echo "  clpcry <password>      Encrypt clipboard content"
  echo "  nocry <password>       Decrypt clipboard content"
  echo
  echo "${CYAN}Text processing:${RESET}"
  echo "  txtcln <delim1> <delim2> Clean text with delimiters"
  echo "  mkhead                 Create Markdown table header"
  echo "  mkbody                 Create Markdown table body"
  echo "  mkgrid                 Create complete Markdown table"
  echo "  lineup                 Convert spaces to newlines"
  echo "  spaceout               Convert newlines to spaces"
  echo "  numcat <file>          Number lines in file"
  echo "  coldwar <text>         Format text in 5-character groups"
  echo "  letonly <text>         Extract only letters"
  echo "  fold64 <text>          Wrap text at 64 characters"
  echo "  colx <column> [file]   Extract specific column"
}

_show_time_help() {
  echo "${GREEN}Time and date functions:${RESET}"
  echo "  epochnow               Show current Unix timestamp"
  echo "  e2h <timestamp>        Convert epoch to human readable"
  echo "  h2e <date>             Convert human date to epoch"
  echo "  utc2local <datetime>   Convert UTC to local timezone"
  echo "  inthepast <days>       Show date N days ago"
  echo "  inthefuture <days>     Show date N days from now"
}

_show_shell_help() {
  echo "${GREEN}Shell functions:${RESET}"
  echo "  hl                     Show recent command history"
  echo "  hg <term>              Search command history"
  echo
  echo "${CYAN}Text processing:${RESET}"
  echo "  tnb                    Show first and last lines"
  echo "  dropone                Remove first line from input"
  echo "  uc <text>              Convert to uppercase"
  echo "  lc <text>              Convert to lowercase"
  echo
  echo "${CYAN}System info:${RESET}"
  echo "  getwin                 Show terminal dimensions"
  echo "  tabname <title>        Set terminal tab title"
  echo
  echo "${CYAN}Prompts:${RESET}"
  echo "  normalprompt           Set standard bash prompt"
  echo "  gitprompt              Set git-aware prompt"
  echo "  exitprompt             Set prompt with exit code colors"
  echo "  githelp                Show comprehensive git help"
  echo "  prompthelp             Show prompt configuration help"
}

_show_terraform_help() {
  echo "${GREEN}Terraform functions:${RESET}"
  echo "  tfchk                  Check available terraform aliases"
  echo "  tfhlp                  Show terraform help"
  echo
  echo "${GRAY}Available aliases:${RESET}"
  echo "  tfini, tfval, tffmt, tfpln, tfapl, tfdes, tfshw, tflst, tfout, tfref, tfimp"
}

_show_function_help() {
  local func="$1"
  local file="${BASH_SOURCE[0]}"

  # Try to find the function definition
  local func_line
  func_line=$(grep -n "^${func}()" "$file" | head -1 | cut -d: -f1)

  if [ -n "$func_line" ]; then
    echo "${CYAN}${func}()${RESET}"

    # Look for comments above the function (up to 10 lines back)
    local start_line=$((func_line > 10 ? func_line - 10 : 1))
    local comment_found=false

    sed -n "${start_line},${func_line}p" "$file" | while IFS= read -r line; do
      if [[ "$line" =~ ^# ]]; then
        echo "$line"
        comment_found=true
      elif [[ "$line" == "${func}()" ]]; then
        break
      fi
    done

    # If no comments found, show basic info
    if ! $comment_found; then
      echo "${GRAY}    No detailed documentation available.${RESET}"
    fi

    echo
    echo "${GRAY}For usage examples, see: funchelp <category>${RESET}"
    echo "${GRAY}Categories: json, notes, network, file, clipboard, time, shell, terraform${RESET}"
  else
    # Check if it's an alias
    local alias_line
    alias_line=$(grep -n "^alias ${func}=" "$file" | head -1)
    if [ -n "$alias_line" ]; then
      echo "$alias_line"
    else
      echo "${RED}funchelp: no help topics match '$func'.${RESET}"
    fi
  fi
}

# -----------------------------------------------------------------------------
# Dependency management and installation
# -----------------------------------------------------------------------------
_detect_package_manager() {
  if command -v apt >/dev/null 2>&1; then
    echo "apt"
  elif command -v dnf >/dev/null 2>&1; then
    echo "dnf"
  elif command -v yum >/dev/null 2>&1; then
    echo "yum"
  elif command -v pacman >/dev/null 2>&1; then
    echo "pacman"
  elif command -v zypper >/dev/null 2>&1; then
    echo "zypper"
  elif command -v brew >/dev/null 2>&1; then
    echo "brew"
  else
    echo "unknown"
  fi
}

_get_package_name() {
  local tool="$1"
  local pm="$2"

  case "$pm" in
    apt)
      case "$tool" in
        jq) echo "jq" ;;
        yq) echo "yq" ;;  # Note: yq v4 might need manual install
        ccrypt) echo "ccrypt" ;;
        uuidgen) echo "util-linux" ;;
        xclip) echo "xclip" ;;
        xsel) echo "xsel" ;;
        wl-clipboard) echo "wl-clipboard" ;;
        neofetch) echo "neofetch" ;;
        terraform) echo "terraform" ;;
        coreutils) echo "coreutils" ;;
        curl) echo "curl" ;;
        grep) echo "grep" ;;
        sed) echo "sed" ;;
        awk) echo "gawk" ;;
        find) echo "findutils" ;;
        date) echo "coreutils" ;;
        printf) echo "coreutils" ;;
        *) echo "$tool" ;;
      esac
      ;;
    dnf|yum)
      case "$tool" in
        jq) echo "jq" ;;
        yq) echo "yq" ;;
        ccrypt) echo "ccrypt" ;;
        uuidgen) echo "util-linux" ;;
        xclip) echo "xclip" ;;
        xsel) echo "xsel" ;;
        wl-clipboard) echo "wl-clipboard" ;;
        neofetch) echo "neofetch" ;;
        terraform) echo "terraform" ;;
        *) echo "$tool" ;;
      esac
      ;;
    pacman)
      case "$tool" in
        jq) echo "jq" ;;
        yq) echo "yq" ;;
        ccrypt) echo "ccrypt" ;;
        uuidgen) echo "util-linux" ;;
        xclip) echo "xclip" ;;
        xsel) echo "xsel" ;;
        wl-clipboard) echo "wl-clipboard" ;;
        neofetch) echo "neofetch" ;;
        terraform) echo "terraform" ;;
        *) echo "$tool" ;;
      esac
      ;;
    brew)
      case "$tool" in
        jq) echo "jq" ;;
        yq) echo "yq" ;;
        ccrypt) echo "ccrypt" ;;
        uuidgen) echo "util-linux" ;;
        xclip) echo "xclip" ;;
        xsel) echo "xsel" ;;
        wl-clipboard) echo "wl-clipboard" ;;
        neofetch) echo "neofetch" ;;
        terraform) echo "terraform" ;;
        coreutils) echo "coreutils" ;;
        *) echo "$tool" ;;
      esac
      ;;
    *)
      echo "$tool"
      ;;
  esac
}

_install_package() {
  local tool="$1"
  local pm="$(_detect_package_manager)"

  if [ "$pm" = "unknown" ]; then
    echo "${RED}Error: Unknown package manager. Please install $tool manually.${RESET}"
    return 1
  fi

  local package="$(_get_package_name "$tool" "$pm")"

  echo "${CYAN}Installing $tool (package: $package) using $pm...${RESET}"

  case "$pm" in
    apt)
      if ! sudo apt update && sudo apt install -y "$package"; then
        echo "${RED}Failed to install $package${RESET}"
        return 1
      fi
      ;;
    dnf)
      if ! sudo dnf install -y "$package"; then
        echo "${RED}Failed to install $package${RESET}"
        return 1
      fi
      ;;
    yum)
      if ! sudo yum install -y "$package"; then
        echo "${RED}Failed to install $package${RESET}"
        return 1
      fi
      ;;
    pacman)
      if ! sudo pacman -S --noconfirm "$package"; then
        echo "${RED}Failed to install $package${RESET}"
        return 1
      fi
      ;;
    brew)
      if ! brew install "$package"; then
        echo "${RED}Failed to install $package${RESET}"
        return 1
      fi
      ;;
  esac

  echo "${GREEN}Successfully installed $tool${RESET}"
}

_check_and_install_deps() {
  local pm="$(_detect_package_manager)"
  echo "${CYAN}Detected package manager: $pm${RESET}"

  # Core dependencies that are always needed
  local core_deps="curl grep sed awk find date printf coreutils"

  # Optional dependencies that enhance functionality
  local optional_deps="jq ccrypt uuidgen neofetch"

  # Clipboard tools (try to install at least one)
  local clipboard_deps="wl-clipboard xclip xsel"

  echo "${CYAN}Checking core dependencies...${RESET}"
  for dep in $core_deps; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      echo "${YELLOW}Missing core dependency: $dep${RESET}"
      if _install_package "$dep"; then
        echo "${GREEN}✓ Installed $dep${RESET}"
      else
        echo "${RED}✗ Failed to install $dep${RESET}"
      fi
    else
      echo "${GREEN}✓ $dep is available${RESET}"
    fi
  done

  echo
  echo "${CYAN}Checking optional dependencies...${RESET}"
  for dep in $optional_deps; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      echo "${YELLOW}Missing optional dependency: $dep${RESET}"
      if _install_package "$dep"; then
        echo "${GREEN}✓ Installed $dep${RESET}"
      else
        echo "${YELLOW}⚠ Failed to install $dep (optional)${RESET}"
      fi
    else
      echo "${GREEN}✓ $dep is available${RESET}"
    fi
  done

  echo
  echo "${CYAN}Checking clipboard tools...${RESET}"
  local clipboard_installed=false
  for dep in $clipboard_deps; do
    if command -v "$dep" >/dev/null 2>&1; then
      echo "${GREEN}✓ $dep is available${RESET}"
      clipboard_installed=true
      break
    fi
  done

  if ! $clipboard_installed; then
    echo "${YELLOW}No clipboard tools found. Installing xclip...${RESET}"
    if _install_package "xclip"; then
      echo "${GREEN}✓ Installed xclip${RESET}"
    else
      echo "${YELLOW}⚠ Failed to install clipboard tools${RESET}"
    fi
  fi

  echo
  echo "${GREEN}Dependency check complete!${RESET}"
  echo "${GRAY}Note: Some tools like 'yq' may need manual installation for specific versions.${RESET}"
}

# Function to install all dependencies
myfuncs_install_deps() {
  echo "${GREEN}MyFuncs Dependency Installer${RESET}"
  echo "This will check for and install required dependencies for MyFuncs."
  echo

  # Check if running as root or can use sudo
  if [ "$EUID" -eq 0 ]; then
    echo "${GREEN}Running as root - proceeding with installation...${RESET}"
  elif command -v sudo >/dev/null 2>&1; then
    echo "${YELLOW}Will use sudo for installation. You may be prompted for your password.${RESET}"
  else
    echo "${RED}Error: Neither running as root nor sudo available. Please install dependencies manually.${RESET}"
    return 1
  fi

  echo
  _check_and_install_deps
}

# Function to install MyFuncs
myfuncs_install() {
  local script_path="${1:-$(pwd)/.myfuncs}"

  echo "${GREEN}MyFuncs Installer${RESET}"
  echo "Installing MyFuncs to your system..."
  echo "This will add a source line to ~/.bashrc pointing to: $script_path"
  echo

  # Check if script exists
  if [ ! -f "$script_path" ]; then
    echo "${RED}Error: .myfuncs not found at $script_path${RESET}" >&2
    echo "Usage: myfuncs_install [path/to/.myfuncs]" >&2
    return 1
  fi

  # Check if already in .bashrc
  if grep -q "source \"$script_path\"" ~/.bashrc; then
    echo "${YELLOW}⚠ MyFuncs is already configured in ~/.bashrc${RESET}"
  else
    # Append to .bashrc
    if echo "source \"$script_path\"" >> ~/.bashrc; then
      echo "${GREEN}✓ Added 'source \"$script_path\"' to ~/.bashrc${RESET}"
    else
      echo "${RED}✗ Failed to update ~/.bashrc${RESET}" >&2
      return 1
    fi
  fi

  echo
  echo "${GREEN}Installation complete!${RESET}"
  echo "The source code remains in: $script_path"
  echo "Run 'myfuncs_install_deps' to install required dependencies."
  echo "Restart your terminal or run 'source ~/.bashrc' to load MyFuncs in new sessions."
}

# Legacy function name for backward compatibility
help() {
  funchelp "$@"
}

# -----------------------------------------------------------------------------
# Window size
# -----------------------------------------------------------------------------
getwin() {
  export lines=$(tput lines)
  export columns=$(tput cols)
  echo "Lines: $lines x Columns: $columns"
}

# -----------------------------------------------------------------------------
# Tab name, works in many terminals that support xterm title
# -----------------------------------------------------------------------------
tabname() { echo -ne "\033]0;$*\007"; }

# -----------------------------------------------------------------------------
# Grep across common env dotfiles
# -----------------------------------------------------------------------------
grepenv() {
  grep -rin --color=always "${1}" ~/.bashrc ~/.bash_aliases ~/.profile ~/.bash_logout 2>/dev/null
}

# -----------------------------------------------------------------------------
# Backup notes to git directory
# -----------------------------------------------------------------------------
backitup() {
  local src_dir=${1:-"$HOME/Documents/MyNotes/"}
  local target_dir="$HOME/gitlab/mynotes"
  if [ ! -d "$target_dir" ]; then
    echo "Target directory $target_dir does not exist." 1>&2
    return 1
  fi
  find "$src_dir" -type f \( -name "*.txt" -o -name "*.yml" -o -name "*.yaml" \) -exec grep -Iq . {} \; -exec cp {} "$target_dir/" \;
  pushd "$target_dir" >/dev/null || return 1
  local commit_msg="MyNotes - $(date +"%d %b %Y %T")"
  git add .
  git commit -m "$commit_msg" || true
  git push origin main
  git status
  popd >/dev/null || true
}

# -----------------------------------------------------------------------------
# CLI tools update (Ubuntu variants)
# -----------------------------------------------------------------------------
update_cli_tools() {
  if command -v apt >/dev/null 2>&1; then
    echo "Updating apt packages..."
    sudo apt update && sudo apt -y upgrade
  fi
  if command -v gcloud >/dev/null 2>&1; then
    echo "Updating Google Cloud SDK..."
    gcloud components update
  fi
  if command -v az >/dev/null 2>&1; then
    echo "Updating Azure CLI..."
    az upgrade -y
  fi
}

# =============================================================================
# End of myfuncs.sh
# =============================================================================

